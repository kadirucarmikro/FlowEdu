import 'dart:typed_data';
import '../../domain/entities/event.dart';
import '../../domain/repositories/events_repository_interface.dart';
import '../data_sources/events_remote_data_source.dart';
import '../models/event_model.dart';

class EventsRepositoryImpl implements EventsRepository {
  EventsRepositoryImpl(this._remoteDataSource);

  final EventsRemoteDataSource _remoteDataSource;

  @override
  Future<List<Event>> getEvents() async {
    final events = await _remoteDataSource.getEvents();
    return events.cast<Event>();
  }

  @override
  Future<Event?> getEventById(String id) async {
    final event = await _remoteDataSource.getEventById(id);
    return event;
  }

  @override
  Future<Event> createEvent({
    required String title,
    String? description,
    String? richDescription,
    String? imageUrl,
    required EventType type,
    required bool isMultipleChoice,
    DateTime? startAt,
    DateTime? endAt,
    String? location,
    int? maxParticipants,
    DateTime? registrationDeadline,
    List<String>? optionTexts,
  }) async {
    final event = EventModel(
      id: '', // Will be generated by database
      title: title,
      description: description,
      richDescription: richDescription,
      imageUrl: imageUrl,
      type: type,
      isMultipleChoice: isMultipleChoice,
      startAt: startAt,
      endAt: endAt,
      location: location,
      maxParticipants: maxParticipants,
      registrationDeadline: registrationDeadline,
      createdAt: DateTime.now(),
    );

    final createdEvent = await _remoteDataSource.createEvent(event);

    // Create options if provided
    if (optionTexts != null && optionTexts.isNotEmpty) {
      for (final optionText in optionTexts) {
        await _remoteDataSource.createEventOption(
          EventOptionModel(
            id: '', // Will be generated by database
            eventId: createdEvent.id,
            optionText: optionText,
          ),
        );
      }
    }

    // Return updated event with options
    return await _remoteDataSource.getEventById(createdEvent.id) ??
        createdEvent;
  }

  @override
  Future<Event> updateEvent({
    required String id,
    String? title,
    String? description,
    String? richDescription,
    String? imageUrl,
    EventType? type,
    bool? isMultipleChoice,
    DateTime? startAt,
    DateTime? endAt,
    String? location,
    int? maxParticipants,
    DateTime? registrationDeadline,
    List<String>? optionTexts,
  }) async {
    final existingEvent = await _remoteDataSource.getEventById(id);
    if (existingEvent == null) {
      throw Exception('Event not found');
    }

    final updatedEvent = EventModel(
      id: id,
      title: title ?? existingEvent.title,
      description: description ?? existingEvent.description,
      richDescription: richDescription ?? existingEvent.richDescription,
      imageUrl: imageUrl ?? existingEvent.imageUrl,
      type: type ?? existingEvent.type,
      isMultipleChoice: isMultipleChoice ?? existingEvent.isMultipleChoice,
      startAt: startAt ?? existingEvent.startAt,
      endAt: endAt ?? existingEvent.endAt,
      location: location ?? existingEvent.location,
      maxParticipants: maxParticipants ?? existingEvent.maxParticipants,
      registrationDeadline:
          registrationDeadline ?? existingEvent.registrationDeadline,
      createdBy: existingEvent.createdBy,
      createdAt: existingEvent.createdAt,
    );

    final result = await _remoteDataSource.updateEvent(updatedEvent);

    // Update options if provided
    if (optionTexts != null) {
      // Delete existing options
      final existingOptions = await _remoteDataSource.getEventOptions(id);
      for (final option in existingOptions) {
        await _remoteDataSource.deleteEventOption(option.id);
      }

      // Create new options
      for (final optionText in optionTexts) {
        await _remoteDataSource.createEventOption(
          EventOptionModel(
            id: '', // Will be generated by database
            eventId: id,
            optionText: optionText,
          ),
        );
      }
    }

    // Return updated event with options
    return await _remoteDataSource.getEventById(id) ?? result;
  }

  @override
  Future<void> deleteEvent(String id) async {
    await _remoteDataSource.deleteEvent(id);
  }

  @override
  Future<List<EventOption>> getEventOptions(String eventId) async {
    final options = await _remoteDataSource.getEventOptions(eventId);
    return options;
  }

  @override
  Future<EventOption> createEventOption({
    required String eventId,
    required String optionText,
  }) async {
    final option = EventOptionModel(
      id: '', // Will be generated by database
      eventId: eventId,
      optionText: optionText,
    );

    return await _remoteDataSource.createEventOption(option);
  }

  @override
  Future<void> deleteEventOption(String optionId) async {
    await _remoteDataSource.deleteEventOption(optionId);
  }

  @override
  Future<List<EventResponse>> getEventResponses(String eventId) async {
    final responses = await _remoteDataSource.getEventResponses(eventId);
    return responses;
  }

  @override
  Future<EventResponse> createEventResponse({
    required String eventId,
    String? optionId,
    String? responseText,
  }) async {
    // Get current member ID from auth
    final currentMember = await _remoteDataSource.getCurrentMember();
    if (currentMember == null) {
      throw Exception('Member not found');
    }

    final memberId = currentMember['id'] as String;

    final response = EventResponseModel(
      id: '', // Will be generated by database
      eventId: eventId,
      memberId: memberId, // Set current member ID from Map
      optionId: optionId,
      responseText: responseText,
      createdAt: DateTime.now(),
    );

    return await _remoteDataSource.createEventResponse(response);
  }

  @override
  Future<EventResponse?> getMemberEventResponse({
    required String eventId,
    required String memberId,
  }) async {
    final response = await _remoteDataSource.getMemberEventResponse(
      eventId: eventId,
      memberId: memberId,
    );
    return response;
  }

  @override
  Future<EventResponse> updateEventResponse({
    required String responseId,
    String? optionId,
    String? responseText,
  }) async {
    final response = EventResponseModel(
      id: responseId,
      eventId: '', // Not needed for update
      memberId: '', // Not needed for update
      optionId: optionId,
      responseText: responseText,
      createdAt: DateTime.now(), // Not needed for update
    );

    return await _remoteDataSource.updateEventResponse(response);
  }

  @override
  Future<void> deleteEventResponse(String responseId) async {
    await _remoteDataSource.deleteEventResponse(responseId);
  }

  // Event Organizers
  @override
  Future<List<EventOrganizer>> getEventOrganizers(String eventId) async {
    final organizers = await _remoteDataSource.getEventOrganizers(eventId);
    return organizers;
  }

  @override
  Future<EventOrganizer> createEventOrganizer({
    required String eventId,
    required String memberId,
    required String role,
  }) async {
    final organizer = EventOrganizerModel(
      id: '', // Will be generated by database
      eventId: eventId,
      memberId: memberId,
      role: role,
      createdAt: DateTime.now(),
    );

    return await _remoteDataSource.createEventOrganizer(organizer);
  }

  @override
  Future<void> deleteEventOrganizer(String organizerId) async {
    await _remoteDataSource.deleteEventOrganizer(organizerId);
  }

  @override
  Future<void> deleteEventOrganizersByEventId(String eventId) async {
    await _remoteDataSource.deleteEventOrganizersByEventId(eventId);
  }

  // Event Instructors
  @override
  Future<List<EventInstructor>> getEventInstructors(String eventId) async {
    final instructors = await _remoteDataSource.getEventInstructors(eventId);
    return instructors;
  }

  @override
  Future<EventInstructor> createEventInstructor({
    required String eventId,
    required String memberId,
    required String role,
  }) async {
    final instructor = EventInstructorModel(
      id: '', // Will be generated by database
      eventId: eventId,
      memberId: memberId,
      role: role,
      createdAt: DateTime.now(),
    );

    return await _remoteDataSource.createEventInstructor(instructor);
  }

  @override
  Future<void> deleteEventInstructor(String instructorId) async {
    await _remoteDataSource.deleteEventInstructor(instructorId);
  }

  @override
  Future<void> deleteEventInstructorsByEventId(String eventId) async {
    await _remoteDataSource.deleteEventInstructorsByEventId(eventId);
  }

  @override
  Future<EventQuestion> createEventQuestion({
    required String eventId,
    required String questionText,
    required String questionType,
    required bool isRequired,
    required int sortOrder,
  }) async {
    return await _remoteDataSource.createEventQuestion(
      eventId: eventId,
      questionText: questionText,
      questionType: questionType,
      isRequired: isRequired,
      sortOrder: sortOrder,
    );
  }

  @override
  Future<void> deleteEventQuestionsByEventId(String eventId) async {
    await _remoteDataSource.deleteEventQuestionsByEventId(eventId);
  }

  @override
  Future<EventQuestionOption> createEventQuestionOption({
    required String questionId,
    required String optionText,
    required int sortOrder,
  }) async {
    return await _remoteDataSource.createEventQuestionOption(
      questionId: questionId,
      optionText: optionText,
      sortOrder: sortOrder,
    );
  }

  @override
  Future<List<EventQuestionOption>> getQuestionOptions(
    String questionId,
  ) async {
    return await _remoteDataSource.getQuestionOptions(questionId);
  }

  @override
  Future<void> updateQuestionResponse({
    required String questionId,
    required String memberId,
    String? optionId,
    required String responseText,
  }) async {
    await _remoteDataSource.updateQuestionResponse(
      questionId: questionId,
      memberId: memberId,
      optionId: optionId,
      responseText: responseText,
    );
  }

  @override
  Future<EventMedia> createEventMedia({
    required String eventId,
    required String fileName,
    required String fileUrl,
    required String fileType,
    int? fileSize,
    String? uploadedBy,
  }) async {
    return await _remoteDataSource.createEventMedia(
      eventId: eventId,
      fileName: fileName,
      fileUrl: fileUrl,
      fileType: fileType,
      fileSize: fileSize,
      uploadedBy: uploadedBy,
    );
  }

  @override
  Future<void> deleteEventMedia(String mediaId) async {
    await _remoteDataSource.deleteEventMedia(mediaId);
  }

  @override
  Future<void> deleteEventMediaByEventId(String eventId) async {
    await _remoteDataSource.deleteEventMediaByEventId(eventId);
  }

  @override
  Future<Map<String, dynamic>?> getCurrentMember() async {
    return await _remoteDataSource.getCurrentMember();
  }

  @override
  Future<List<EventQuestionResponse>> getQuestionResponses({
    required String eventId,
    required String memberId,
  }) async {
    final responses = await _remoteDataSource.getQuestionResponses(
      eventId: eventId,
      memberId: memberId,
    );
    return responses;
  }

  @override
  Future<EventQuestionResponse> createQuestionResponse({
    required String questionId,
    required String memberId,
    String? optionId,
    String? responseText,
  }) async {
    final response = await _remoteDataSource.createQuestionResponse(
      questionId: questionId,
      memberId: memberId,
      optionId: optionId,
      responseText: responseText,
    );
    return response;
  }

  @override
  Future<List<EventQuestionResponse>> getAllQuestionResponsesForEvent(
    String eventId,
  ) async {
    final responses = await _remoteDataSource.getAllQuestionResponsesForEvent(
      eventId,
    );
    return responses;
  }

  @override
  Future<String> uploadFileToStorage({
    required String fileName,
    required List<int> fileBytes,
    required String fileType,
  }) async {
    return await _remoteDataSource.uploadFileToStorage(
      fileName: fileName,
      fileBytes: Uint8List.fromList(fileBytes),
      fileType: fileType,
    );
  }
}
